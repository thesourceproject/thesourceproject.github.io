(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{262:function(e,t,n){"use strict";n.r(t);var r=n(110),o=n(111),l={name:"competitive6",components:{ArticleHeader:r.default,CodeSnippet:o.default},head:{title:"LeetCode #1 Two Sum | The Source Project",meta:[{hid:"description",name:"description",content:"Check out this problem on LeetCode. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target."}]}},v=n(8),component=Object(v.a)(l,(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("main",[n("article",{staticClass:"w-full max-w-4xl mx-auto flex flex-col"},[n("ArticleHeader",{attrs:{title:"LeetCode #1 Two Sum",date:"20 Feb '21",readTime:"10 min read",tags:["competitive","data","structures","algorithms","java","python","beginner"]}}),e._v(" "),e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),n("CodeSnippet",{attrs:{code:"// Java\npublic int[] twoSum(int[] nums, int target) {\n    for(int i = 0; i < nums.length; i++) {\n        for(int j = 0; j < nums.length; j++) {\n            if(i != j) { // You may not use the same element twice.\n                if(nums[i] + nums[j] == target) {\n                    return new int[] {i, j}; // Return the indices in an array.\n                }\n            }\n        }\n    }\n    return new int[] {-1, -1}; // Default return value if there is no solution.\n}",lang:"language-java"}}),e._v(" "),n("CodeSnippet",{attrs:{code:"# Python3\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if(i != j):\n                if(nums[i] + nums[j] == target):\n                    return [i, j]",lang:"language-python"}}),e._v(" "),e._m(6),e._v(" "),n("CodeSnippet",{attrs:{code:"// Java\npublic int[] twoSum(int[] nums, int target) {\n    for(int i = 0; i < nums.length; i++) {\n        for(int j = i + 1; j < nums.length; j++) {\n            if(nums[i] + nums[j] == target) {\n                return new int[] {i, j};\n            }\n        }\n    }\n    return new int[] {-1, -1};\n}",lang:"language-java"}}),e._v(" "),n("CodeSnippet",{attrs:{code:"# Python3\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if(nums[i] + nums[j] == target):\n                return [i, j]",lang:"language-python"}}),e._v(" "),n("p",[e._v("\n        This solution like the previous one has a space complexity of\n        "),n("strong",[e._v("O(1)")]),e._v(" as we only use a constant amount of memory to\n        store our variables. Notice now we don't have to check for\n        "),n("em",[e._v("i != j")]),e._v(" as i and j will never be equal."),n("br"),n("br"),e._v("\n        We improved our solution slightly but it's time complexity is still\n        "),e._m(7),e._v(". This is because in the worst case our\n        solution checks (n - 1) + (n - 2) + (n - 3) + ... + 2 + 1 = (n)(n - 1) รท\n        2 pairs, thereby giving it an upper bound of\n        "),e._m(8),e._v("."),n("br"),n("br"),e._v("\n        Can we bring our solution down to\n        "),n("strong",[e._v("O(n)?")]),n("br"),e._v("\n        Yes! We can. Here comes\n        "),n("strong",[e._v("HashMap/Dictionary")]),e._v(" to the rescue."),n("br"),n("br"),e._v("\n        Java Hashmaps & Python Dictionaries can store key-value pairs that\n        allow lookup in "),n("strong",[e._v("O(1)")]),e._v(" time. But how will it help us? For\n        every number, if we could check whether its difference from\n        "),n("strong",[e._v("target")]),e._v(" exists in the array, we will get the answer."),n("br"),e._v(" "),n("strong",[e._v("Note")]),e._v(" - You can learn more about\n        "),n("NuxtLink",{staticClass:"text-text-3 hover:underline focus:underline focus:outline-none",attrs:{to:"/article/8-Using-inbuilt-data-structures-of-Java"}},[e._v("HashMaps")]),e._v("\n        and\n        "),n("NuxtLink",{staticClass:"text-text-3 hover:underline focus:underline focus:outline-none",attrs:{to:"/article/9-Using-inbuilt-data-structures-of-Python"}},[e._v("Dictionaries")]),e._v("\n        in our tutorials.\n      ")],1),e._v(" "),n("CodeSnippet",{attrs:{code:"// Java\n// import java.util.*; // For the HashMap class, it is automatically imported on LeetCode.\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> indices = new HashMap<>();\n    for(int i = 0; i < nums.length; i++) {\n        if(indices.containsKey(target - nums[i])) {\n            return new int[] {indices.get(target - nums[i]), i};\n        }\n        indices.put(nums[i], i);\n    }\n    return new int[] {-1, -1};\n}",lang:"language-java"}}),e._v(" "),n("CodeSnippet",{attrs:{code:"# Python3\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    indices = {};\n    for i in range(len(nums)):\n        if((target - nums[i]) in indices):\n            return [indices[target - nums[i]], i]\n        indices[nums[i]] = i",lang:"language-python"}}),e._v(" "),e._m(9)],1)])}),[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n        Check out\n        "),n("a",{staticClass:"text-text-3 hover:underline focus:underline focus:outline-none",attrs:{rel:"noopener noreferrer",href:"https://leetcode.com/problems/two-sum/",target:"_blank"}},[e._v("this")]),e._v("\n        problem on LeetCode.\n      ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("a",{staticClass:"mx-auto mt-6 p-6 bg-white rounded-2xl",attrs:{rel:"noopener noreferrer",title:"LeetCode, Public domain, via Wikimedia Commons",href:"https://commons.wikimedia.org/wiki/File:LeetCode_Logo_black_with_text.svg",target:"_blank"}},[t("img",{staticClass:"w-96",attrs:{alt:"LeetCode Logo black with text",src:"https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/LeetCode_Logo_black_with_text.svg/640px-LeetCode_Logo_black_with_text.svg.png"}})])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",{staticClass:"mt-6"},[e._v("\n        Given an array of integers "),n("strong",[e._v("nums")]),e._v(" and an integer\n        "),n("strong",[e._v("target")]),e._v(", return\n        "),n("em",[e._v("indices of the two numbers such that they add up to\n          "),n("strong",[e._v("target")])]),e._v("."),n("br"),e._v("\n        You may assume that each input would have\n        "),n("strong",[n("em",[e._v("exactly")]),e._v(" one solution")]),e._v(", and you may not use the\n        "),n("em",[e._v("same")]),e._v(" element twice."),n("br"),e._v("\n        You can return the answer in any order."),n("br"),n("br"),e._v(" "),n("strong",{staticClass:"text-lg"},[e._v("Example 1:")]),n("br"),e._v(" "),n("strong",[e._v("Input:")]),e._v(" nums = [2, 7, 11, 15], target = 9"),n("br"),e._v(" "),n("strong",[e._v("Output:")]),e._v(" [0, 1]"),n("br"),e._v(" "),n("strong",[e._v("Explanation:")]),e._v(" Because nums[0] + nums[1] == 9, we return\n        [0, 1]."),n("br"),n("br"),e._v(" "),n("strong",{staticClass:"text-lg"},[e._v("Example 2:")]),n("br"),e._v(" "),n("strong",[e._v("Input:")]),e._v(" nums = [3, 2, 4], target = 6"),n("br"),e._v(" "),n("strong",[e._v("Output:")]),e._v(" [1, 2]"),n("br"),n("br"),e._v(" "),n("strong",{staticClass:"text-lg"},[e._v("Example 3:")]),n("br"),e._v(" "),n("strong",[e._v("Input:")]),e._v(" nums = [3, 3], target = 6"),n("br"),e._v(" "),n("strong",[e._v("Output:")]),e._v(" [0, 1]"),n("br"),n("br"),e._v(" "),n("strong",{staticClass:"text-lg"},[e._v("Constraints:")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",{staticClass:"list-disc list-inside"},[n("li",[e._v("2 <= nums.length <= 10"),n("sup",[e._v("3")])]),e._v(" "),n("li",[e._v("-10"),n("sup",[e._v("9")]),e._v(" <= nums[i] <= 10"),n("sup",[e._v("9")])]),e._v(" "),n("li",[e._v("-10"),n("sup",[e._v("9")]),e._v(" <= target <= 10"),n("sup",[e._v("9")])]),e._v(" "),n("li",[e._v("Only one valid answer exists.")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"mt-12 flex flex-col"},[n("h2",{staticClass:"text-2xl"},[e._v("Getting Started")]),e._v(" "),n("div",{staticClass:"w-6 h-1 bg-background-2 rounded-full"})])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",{staticClass:"mt-8"},[e._v("\n        We need to find a pair of numbers in the given array that adds up to\n        "),n("strong",[e._v("target")]),e._v(". The most straightforward way to find it is to\n        try every possible pair.\n      ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n        Notice that we added a default return value in the Java code at the end.\n        This is because the return type of the function is of\n        "),n("strong",[e._v("int[]")]),e._v(" type, therefore the function must return an array\n        of integers for all conditions. This is not required in the Python\n        version as the question states that we will get a unique solution for\n        every test case."),n("br"),n("br"),e._v("\n        This solution has a time complexity of\n        "),n("strong",[e._v("O(n"),n("sup",[e._v("2")]),e._v(")")]),e._v(" because we run 2 nested loops which\n        each run for the complete length of the array in the worst case. If we\n        submit this, it will get accepted. But we can improve upon this solution\n        slightly."),n("br"),n("br"),e._v("\n        If you see our code, it runs 2 loops from the beginning and we are\n        checking every pair 2 times. For example, initially we check the pair\n        (i, j) = (0, 1) and when the inner loop completes once, we check the\n        pair (i, j) = (1, 0). The sum is going to be the same in either order so\n        we can save some time by skipping these pairs."),n("br"),e._v("\n        Let's see how we can achieve this."),n("br"),n("br"),e._v("\n        Suppose there's an array [0, 1, 2, 3, 4]. In the first outer loop we\n        will check the pairs (0, 1), (0, 2), (0, 3), (0, 4). For the next loop,\n        we can start from (1, 2) instead of (1, 0) and continue (1, 3), (1, 4).\n        And then (2, 3), (2, 4) and finally (3, 4)."),n("br"),e._v("\n        We observe that we can start the inner loop from "),n("em",[e._v("i + 1")]),e._v(" to avoid\n        the visited pairs.\n      ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("strong",[e._v("O(n"),n("sup",[e._v("2")]),e._v(")")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("strong",[e._v("O(n"),n("sup",[e._v("2")]),e._v(")")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n        Here we create a HashMap/Dictionary to store the indices of the array\n        elements. Then we traverse over the array while checking if we have\n        encountered "),n("em",[e._v("target - nums[i]")]),e._v(" previously. If not, we store the\n        index with the array element as the key in our HashMap/Dictionary."),n("br"),n("br"),e._v("\n        So now we have a solution with a time complexity of\n        "),n("strong",[e._v("O(n)")]),e._v(" making it much faster than the previous ones,\n        however it also has a space complexity of "),n("strong",[e._v("O(n)")]),e._v(" because\n        we are using additional memory for the HashMap/Dictionary proportional\n        to the size of the input array in the worst case."),n("br"),n("br"),e._v("\n        So why stop here? Try some more problems and keep on learning.\n      ")])}],!1,null,null,null);t.default=component.exports;installComponents(component,{ArticleHeader:n(110).default,CodeSnippet:n(111).default})}}]);