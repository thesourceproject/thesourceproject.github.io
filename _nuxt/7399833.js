(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{239:function(e,t,n){"use strict";n.r(t);var r=n(110),o=n(111),l={name:"competitive13",components:{ArticleHeader:r.default,CodeSnippet:o.default},head:{title:"LeetCode #560 Subarray Sum Equals K | The Source Project",meta:[{hid:"description",name:"description",content:"Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k."}]}},m=n(8),component=Object(m.a)(l,(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("main",[n("article",{staticClass:"w-full max-w-4xl mx-auto flex flex-col"},[n("ArticleHeader",{attrs:{title:"LeetCode #560 Subarray Sum Equals K",date:"19 Apr '21",readTime:"10 min read",tags:["competitive","data","structures","algorithms","java","python","intermediate"]}}),e._v(" "),e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),n("p",{staticClass:"mt-8"},[e._v("\n        A "),n("strong",[e._v("subarray")]),e._v(" is a contiguous sequence of items within an\n        array. For example, [1, 2] and [1, 2, 3] are subarrays of [0, 1, 2,\n        3]."),n("br"),e._v("\n        Before finding an optimal solution to a problem, we should always try\n        the brute-force technique. It helps us understand it better. We will\n        start by checking every subarray whether it adds up to the given\n        target."),n("br"),e._v(" "),n("strong",[e._v("Note")]),e._v(" - This is an intermediate-level problem. If you\n        are a beginner, you might want to solve\n        "),n("NuxtLink",{staticClass:"text-text-3 hover:underline focus:underline focus:outline-none",attrs:{to:"/article/6-LeetCode-1-Two-Sum"}},[e._v("this problem")]),e._v("\n        before you continue.\n      ")],1),e._v(" "),n("CodeSnippet",{attrs:{code:'// Java\npublic int subarraySum(int[] nums, int k) {\n    int ans = 0; // Store the answer.\n    for (int left = 0; left < nums.length; ++left) { // Run a loop from "0" to "nums.length - 1" for the left-index.\n        for (int right = left; right < nums.length; ++right) { // Run a loop from "left" to "nums.length - 1" for the right-index.\n            int sum = 0; // Store the sum of current subarray.\n            for (int i = left; i <= right; ++i) { // Run a loop from "left" to "right".\n                sum += nums[i]; // Add the current number to "sum".\n            }\n            if (sum == k) { // If "sum" is equal to "k", increment "ans".\n                ++ans;\n            }\n        }\n    }\n    return ans; // Return the answer.\n}',lang:"language-java"}}),e._v(" "),n("CodeSnippet",{attrs:{code:'# Python3\ndef subarraySum(nums: List[int], k: int) -> int:\n    ans = 0  # Store the answer.\n    for left in range(len(nums)):  # Run a loop from "0" to "nums.length - 1" for the left-index.\n        for right in range(left, len(nums)):  # Run a loop from "left" to "nums.length - 1" for the right-index.\n            sum = 0  # Store the sum of current subarray.\n            for i in range(left, right + 1):  # Run a loop from "left" to "right".\n                sum += nums[i]  # Add the current number to "sum".\n            if(sum == k):  # If "sum" is equal to "k", increment "ans".\n                ans += 1\n    return ans  # Return the answer.',lang:"language-python"}}),e._v(" "),e._m(5),e._v(" "),n("CodeSnippet",{attrs:{code:'// Java\npublic int subarraySum(int[] nums, int k) {\n    for (int i = 1; i < nums.length; ++i) { // Generate the prefix-sum array.\n        nums[i] += nums[i - 1]; // Add the cumulative sum of the previous index.\n    }\n    int ans = 0;\n    for (int left = 0; left < nums.length; ++left) {\n        for (int right = left; right < nums.length; ++right) {\n            int lSum = 0; // Initial sum is "0" before the left-most number.\n            if (left > 0) {\n                lSum = nums[left - 1]; // Cumulative sum of numbers till "left - 1".\n            }\n            int rSum = nums[right]; // Cumulative sum of numbers to till "right".\n            if (rSum - lSum == k) {\n                ++ans;\n            }\n        }\n    }\n    return ans;\n}',lang:"language-java"}}),e._v(" "),n("CodeSnippet",{attrs:{code:'# Python3\ndef subarraySum(nums: List[int], k: int) -> int:\n    for i in range(1, len(nums)):  # Generate the prefix-sum array.\n        nums[i] += nums[i - 1]  # Add the cumulative sum of the previous index.\n    ans = 0\n    for left in range(len(nums)):\n        for right in range(left, len(nums)):\n            lSum = 0  # Initial sum is "0" before the left-most number.\n            if(left > 0):\n                lSum = nums[left - 1]  # Cumulative sum of numbers till "left - 1".\n            rSum = nums[right]  # Cumulative sum of numbers to till "right".\n            if(rSum - lSum == k):\n                ans += 1\n    return ans',lang:"language-python"}}),e._v(" "),n("p",[e._v("\n        We have optimized our solution to "),e._m(6),e._v(", as\n        the subarray sum is obtained in constant time now. The space complexity\n        is either "),n("strong",[e._v("O(n)")]),e._v(" or "),n("strong",[e._v("O(1)")]),e._v(" depending on\n        whether or not modifying the original array counts as using extra\n        space."),n("br"),e._v("\n        This solution is much faster than the previous one but still too\n        slow."),n("br"),n("br"),e._v("\n        At first glance, this problem might appear to be solvable with the\n        "),n("NuxtLink",{staticClass:"text-text-3 hover:underline focus:underline focus:outline-none",attrs:{to:"/article/11-LeetCode-3-Longest-Substring-Without-Repeating-Characters"}},[e._v("sliding window technique")]),e._v(", but it's not the case. Let's see why. Suppose, we have a large array\n        like [1, -1, 1, -1......1, -1, 1] and the target sum is 0. The number of\n        subarrays with an equal number of 0's and 1's are of an order of\n        "),e._m(7),e._v(". A sliding window will not be able to count all of these. This is\n        because a sliding window expands towards the right and shrinks from the\n        left "),n("strong",[e._v("n")]),e._v(" times each."),n("br"),e._v("\n        Let's consider the previous example again. [1, -1, 1, -1, 1, -1] can be\n        modified to a prefix-sum array [1, 0, 1, 0, 1, 0]. If the target sum is\n        0, the subarrays will be 9 in total. Let's traverse our prefix-sum array\n        "),n("em",[e._v("sum")]),e._v(" from left to right to see if we can find a pattern."),n("br"),n("br"),e._v("\n        At "),n("em",[e._v("nums[0]")]),e._v(" our "),n("em",[e._v("rSum")]),e._v(" is 1. To obtain 0 as the final\n        sum, we need to find an "),n("em",[e._v("lSum")]),e._v(" equal to 1(i.e. 1 - 1 = 0). As\n        this is the first index, we cannot find a non-zero "),n("em",[e._v("lSum")]),e._v(" to the\n        left."),n("br"),e._v("\n        At "),n("em",[e._v("nums[1]")]),e._v(" our "),n("em",[e._v("rSum")]),e._v(" is 0. We need to find an\n        "),n("em",[e._v("lSum")]),e._v(" equal to 0. This time, the "),n("em",[e._v("lSum")]),e._v(" before the first\n        index(initial sum) is equal to zero. So, we have obtained one subarray\n        so far."),n("br"),e._v("\n        At "),n("em",[e._v("nums[2]")]),e._v(", our "),n("em",[e._v("rSum")]),e._v(" is 1. We have already encountered\n        a 1 before and can obtain another subarray, bringing our tally to 2."),n("br"),e._v("\n        At "),n("em",[e._v("nums[3]")]),e._v(", our "),n("em",[e._v("rSum")]),e._v(" is 0. We have encountered 0\n        twice(before the first index and at index-1) and can obtain two more\n        zero-sum subarrays."),n("br"),e._v("\n        We repeat this process for the remaining elements to find a total of 9\n        subarrays."),n("br"),n("br"),e._v("\n        We notice that if the target sum is "),n("em",[e._v("k")]),e._v(", for every cumulative sum\n        "),n("em",[e._v("rSum")]),e._v(", we need to find the total number of cumulative sums to\n        the left that are equal to "),n("em",[e._v("rSum - k")]),e._v(" (since\n        "),n("em",[e._v("rSum - lSum = k")]),e._v(")."),n("br"),e._v("\n        Now, let's look at the code.\n      ")],1),e._v(" "),n("CodeSnippet",{attrs:{code:'// Java\npublic int subarraySum(int[] nums, int k) {\n    for (int i = 1; i < nums.length; ++i) {\n        nums[i] += nums[i - 1];\n    }\n    Map<Integer, Integer> count = new HashMap<>(); // Maintain a count of each sum obtained so far.\n    count.put(0, 1); // Initial sum of "0" encountered once at the beginning.\n    int ans = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        ans += count.getOrDefault(nums[i] - k, 0); // Add the count of "nums[i] - k" encountered till now.\n        count.put(nums[i], count.getOrDefault(nums[i], 0) + 1); // Increment the count of the current sum "nums[i]".\n    }\n    return ans;\n}',lang:"language-java"}}),e._v(" "),n("CodeSnippet",{attrs:{code:'# Python3\ndef subarraySum(nums: List[int], k: int) -> int:\n    from collections import defaultdict  # Dictionary that returns a default value for non-existing keys.\n    for i in range(1, len(nums)):\n        nums[i] += nums[i - 1]\n    ans = 0\n    count = defaultdict(int)  # Maintain a count of each sum obtained so far. This "defaultdict" returns "0" by default.\n    count[0] = 1  # Initial sum of "0" encountered once at the beginning.\n    for i in range(len(nums)):\n        ans += count[nums[i] - k]  # Add the count of "nums[i] - k" encountered till now.\n        count[nums[i]] += 1  # Increment the count of the current sum "nums[i]".\n    return ans',lang:"language-python"}}),e._v(" "),e._m(8)],1)])}),[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n        Check out\n        "),n("a",{staticClass:"text-text-3 hover:underline focus:underline focus:outline-none",attrs:{rel:"noopener noreferrer",href:"https://leetcode.com/problems/subarray-sum-equals-k/",target:"_blank"}},[e._v("this")]),e._v("\n        problem on LeetCode.\n      ")])},function(){var e=this.$createElement,t=this._self._c||e;return t("a",{staticClass:"mx-auto mt-6 p-6 bg-white rounded-2xl",attrs:{rel:"noopener noreferrer",title:"LeetCode, Public domain, via Wikimedia Commons",href:"https://commons.wikimedia.org/wiki/File:LeetCode_Logo_black_with_text.svg",target:"_blank"}},[t("img",{staticClass:"w-96",attrs:{alt:"LeetCode Logo black with text",src:"https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/LeetCode_Logo_black_with_text.svg/640px-LeetCode_Logo_black_with_text.svg.png"}})])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",{staticClass:"mt-6"},[e._v("\n        Given an array of integers "),n("strong",[e._v("nums")]),e._v(" and an integer\n        "),n("strong",[e._v("k")]),e._v(", return the total number of continuous subarrays\n        whose sum equals to "),n("strong",[e._v("k")]),e._v("."),n("br"),n("br"),e._v(" "),n("strong",{staticClass:"text-lg"},[e._v("Example 1:")]),n("br"),e._v(" "),n("strong",[e._v("Input:")]),e._v(" nums = nums = [1,1,1], k = 2"),n("br"),e._v(" "),n("strong",[e._v("Output:")]),e._v(" 2"),n("br"),n("br"),e._v(" "),n("strong",{staticClass:"text-lg"},[e._v("Example 2:")]),n("br"),e._v(" "),n("strong",[e._v("Input:")]),e._v(" nums = [1,2,3], k = 3"),n("br"),e._v(" "),n("strong",[e._v("Output:")]),e._v(" 2"),n("br"),n("br"),e._v(" "),n("strong",{staticClass:"text-lg"},[e._v("Constraints:")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ul",{staticClass:"list-disc list-inside"},[n("li",[e._v("1 <= nums.length <= 2 * 10"),n("sup",[e._v("4")])]),e._v(" "),n("li",[e._v("-1000 <= nums[i] <= 1000")]),e._v(" "),n("li",[e._v("-10"),n("sup",[e._v("7")]),e._v(" <= k <= 10"),n("sup",[e._v("7")])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"mt-12 flex flex-col"},[n("h2",{staticClass:"text-2xl"},[e._v("Getting Started")]),e._v(" "),n("div",{staticClass:"w-6 h-1 bg-background-2 rounded-full"})])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n        This solution takes "),n("strong",[e._v("O(n"),n("sup",[e._v("3")]),e._v(")")]),e._v(" time due to the\n        three nested for-loops. No extra space is necessary for this."),n("br"),e._v("\n        We can make a simple optimization to this. Instead of running a loop to\n        find the sum of every subarray, we can obtain it directly using a\n        prefix-sum array. We will modify the original array to store the\n        cumulative sum of all numbers until that index."),n("br"),e._v("\n        For example, if we have an array [1, 2, 3, 4, 5], it will be modified to\n        [1, 3, 6, 10, 15]. Now, if we wanted to find the sum from index 2 to\n        4(inclusive), we simply subtract\n        "),n("em",[e._v("nums[1]")]),e._v(" from "),n("em",[e._v("nums[4]")]),e._v(" to obtain 12. To visualize this,\n        "),n("em",[e._v("(1 + 2 + 3 + 4 + 5) - (1 + 2) = (3 + 4 + 5)")]),e._v(".\n      ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("strong",[e._v("O(n"),n("sup",[e._v("2")]),e._v(")")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("strong",[e._v("n"),n("sup",[e._v("2")])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("\n        This solution has the optimal "),n("strong",[e._v("O(n)")]),e._v(" time complexity. It\n        also uses "),n("strong",[e._v("O(n)")]),e._v(" extra space for the\n        "),n("em",[e._v("count")]),e._v(" map/dictionary."),n("br"),e._v("\n        The problem turned out to be much simpler than it looked. We started\n        from the brute-force technique and optimized it further and further by\n        observing patterns."),n("br"),n("br"),e._v("\n        Hooray! You've solved a medium-level problem. But don't stop here and\n        try some more problems.\n      ")])}],!1,null,null,null);t.default=component.exports;installComponents(component,{ArticleHeader:n(110).default,CodeSnippet:n(111).default})}}]);