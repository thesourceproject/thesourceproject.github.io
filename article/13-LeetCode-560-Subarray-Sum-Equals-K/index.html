<!doctype html>
<html data-n-head-ssr>
  <head>
    <title>LeetCode #560 Subarray Sum Equals K | The Source Project</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="google-site-verification" name="google-site-verification" content="NBXKl5RAGYQH3Rp9PKrszzdV4bRMOLkHjIjvfNDo2xE"><meta data-n-head="ssr" data-hid="description" name="description" content="Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k."><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.png"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=McLaren&family=Poppins&family=Ubuntu+Mono&display=swap"><link rel="preload" href="/_nuxt/5a581fa.js" as="script"><link rel="preload" href="/_nuxt/84f9ad6.js" as="script"><link rel="preload" href="/_nuxt/css/80717b5.css" as="style"><link rel="preload" href="/_nuxt/bababfc.js" as="script"><link rel="preload" href="/_nuxt/css/5d81c44.css" as="style"><link rel="preload" href="/_nuxt/8e6facb.js" as="script"><link rel="preload" href="/_nuxt/7399833.js" as="script"><link rel="stylesheet" href="/_nuxt/css/80717b5.css"><link rel="stylesheet" href="/_nuxt/css/5d81c44.css"><link rel="preload" href="/_nuxt/static/1618949658/article/13-LeetCode-560-Subarray-Sum-Equals-K/state.js" as="script"><link rel="preload" href="/_nuxt/static/1618949658/article/13-LeetCode-560-Subarray-Sum-Equals-K/payload.js" as="script"><link rel="preload" href="/_nuxt/static/1618949658/manifest.js" as="script">
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="min-h-screen flex flex-col bg-background-1 text-text-1 font-body break-words transition-colors light"><header class="container mx-auto px-4 py-6 sm:px-8 flex items-center justify-between"><a href="/" class="font-title text-lg text-text-4 nuxt-link-active"><span class="select-none">TheSourceProject<strong class="text-text-3">_</strong></span></a> <nav class="hidden md:inline mx-auto"><a href="/" class="hover:underline focus:underline focus:outline-none nuxt-link-active">Home</a> <a href="/about-us" class="ml-4 hover:underline focus:underline focus:outline-none">About Us
    </a></nav> <nav class="flex items-center"><button title="Change Theme" class="p-2"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="h-4 w-4"><path fill="currentColor" d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"></path></svg></button> <a href="/find" title="Find Article" class="ml-2 sm:ml-4 bg-background-2 px-6 py-2 rounded-full text-text-2"><figure class="flex items-center"><figcaption class="mr-4">Find</figcaption> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="h-4 w-4"><path fill="currentColor" d="M12.9 14.32a8 8 0 1 1 1.41-1.41l5.35 5.33-1.42 1.42-5.33-5.34zM8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12z"></path></svg></figure></a></nav></header> <main class="flex-grow container mx-auto p-4 sm:px-8 flex flex-col leading-loose"><article class="w-full max-w-4xl mx-auto flex flex-col"><header class="my-8 flex flex-col"><h1 class="text-5xl font-bold leading-snug">LeetCode #560 Subarray Sum Equals K</h1> <p class="mt-6 opacity-50">19 Apr '21 | 10 min read</p> <p class="mt-2 flex flex-wrap"><a href="/find?q=competitive" class="mr-4 hover:underline focus:underline focus:outline-none">
      #competitive
    </a><a href="/find?q=data" class="mr-4 hover:underline focus:underline focus:outline-none">
      #data
    </a><a href="/find?q=structures" class="mr-4 hover:underline focus:underline focus:outline-none">
      #structures
    </a><a href="/find?q=algorithms" class="mr-4 hover:underline focus:underline focus:outline-none">
      #algorithms
    </a><a href="/find?q=java" class="mr-4 hover:underline focus:underline focus:outline-none">
      #java
    </a><a href="/find?q=python" class="mr-4 hover:underline focus:underline focus:outline-none">
      #python
    </a><a href="/find?q=intermediate" class="mr-4 hover:underline focus:underline focus:outline-none">
      #intermediate
    </a></p></header> <p>
        Check out
        <a rel="noopener noreferrer" href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" class="text-text-3 hover:underline focus:underline focus:outline-none">this</a>
        problem on LeetCode.
      </p> <a rel="noopener noreferrer" title="LeetCode, Public domain, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:LeetCode_Logo_black_with_text.svg" target="_blank" class="mx-auto mt-6 p-6 bg-white rounded-2xl"><img alt="LeetCode Logo black with text" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/LeetCode_Logo_black_with_text.svg/640px-LeetCode_Logo_black_with_text.svg.png" class="w-96"></a> <p class="mt-6">
        Given an array of integers <strong>nums</strong> and an integer
        <strong>k</strong>, return the total number of continuous subarrays
        whose sum equals to <strong>k</strong>.<br><br> <strong class="text-lg">Example 1:</strong><br> <strong>Input:</strong> nums = nums = [1,1,1], k = 2<br> <strong>Output:</strong> 2<br><br> <strong class="text-lg">Example 2:</strong><br> <strong>Input:</strong> nums = [1,2,3], k = 3<br> <strong>Output:</strong> 2<br><br> <strong class="text-lg">Constraints:</strong></p> <ul class="list-disc list-inside"><li>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></li> <li>-1000 &lt;= nums[i] &lt;= 1000</li> <li>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></li></ul> <div class="mt-12 flex flex-col"><h2 class="text-2xl">Getting Started</h2> <div class="w-6 h-1 bg-background-2 rounded-full"></div></div> <p class="mt-8">
        A <strong>subarray</strong> is a contiguous sequence of items within an
        array. For example, [1, 2] and [1, 2, 3] are subarrays of [0, 1, 2,
        3].<br>
        Before finding an optimal solution to a problem, we should always try
        the brute-force technique. It helps us understand it better. We will
        start by checking every subarray whether it adds up to the given
        target.<br> <strong>Note</strong> - This is an intermediate-level problem. If you
        are a beginner, you might want to solve
        <a href="/article/6-LeetCode-1-Two-Sum" class="text-text-3 hover:underline focus:underline focus:outline-none">this problem</a>
        before you continue.
      </p> <div class="sm:mx-10 my-4"><pre><code class="language-java">// Java
public int subarraySum(int[] nums, int k) {
    int ans = 0; // Store the answer.
    for (int left = 0; left &lt; nums.length; ++left) { // Run a loop from "0" to "nums.length - 1" for the left-index.
        for (int right = left; right &lt; nums.length; ++right) { // Run a loop from "left" to "nums.length - 1" for the right-index.
            int sum = 0; // Store the sum of current subarray.
            for (int i = left; i &lt;= right; ++i) { // Run a loop from "left" to "right".
                sum += nums[i]; // Add the current number to "sum".
            }
            if (sum == k) { // If "sum" is equal to "k", increment "ans".
                ++ans;
            }
        }
    }
    return ans; // Return the answer.
}</code></pre></div> <div class="sm:mx-10 my-4"><pre><code class="language-python"># Python3
def subarraySum(nums: List[int], k: int) -> int:
    ans = 0  # Store the answer.
    for left in range(len(nums)):  # Run a loop from "0" to "nums.length - 1" for the left-index.
        for right in range(left, len(nums)):  # Run a loop from "left" to "nums.length - 1" for the right-index.
            sum = 0  # Store the sum of current subarray.
            for i in range(left, right + 1):  # Run a loop from "left" to "right".
                sum += nums[i]  # Add the current number to "sum".
            if(sum == k):  # If "sum" is equal to "k", increment "ans".
                ans += 1
    return ans  # Return the answer.</code></pre></div> <p>
        This solution takes <strong>O(n<sup>3</sup>)</strong> time due to the
        three nested for-loops. No extra space is necessary for this.<br>
        We can make a simple optimization to this. Instead of running a loop to
        find the sum of every subarray, we can obtain it directly using a
        prefix-sum array. We will modify the original array to store the
        cumulative sum of all numbers until that index.<br>
        For example, if we have an array [1, 2, 3, 4, 5], it will be modified to
        [1, 3, 6, 10, 15]. Now, if we wanted to find the sum from index 2 to
        4(inclusive), we simply subtract
        <em>nums[1]</em> from <em>nums[4]</em> to obtain 12. To visualize this,
        <em>(1 + 2 + 3 + 4 + 5) - (1 + 2) = (3 + 4 + 5)</em>.
      </p> <div class="sm:mx-10 my-4"><pre><code class="language-java">// Java
public int subarraySum(int[] nums, int k) {
    for (int i = 1; i &lt; nums.length; ++i) { // Generate the prefix-sum array.
        nums[i] += nums[i - 1]; // Add the cumulative sum of the previous index.
    }
    int ans = 0;
    for (int left = 0; left &lt; nums.length; ++left) {
        for (int right = left; right &lt; nums.length; ++right) {
            int lSum = 0; // Initial sum is "0" before the left-most number.
            if (left > 0) {
                lSum = nums[left - 1]; // Cumulative sum of numbers till "left - 1".
            }
            int rSum = nums[right]; // Cumulative sum of numbers to till "right".
            if (rSum - lSum == k) {
                ++ans;
            }
        }
    }
    return ans;
}</code></pre></div> <div class="sm:mx-10 my-4"><pre><code class="language-python"># Python3
def subarraySum(nums: List[int], k: int) -> int:
    for i in range(1, len(nums)):  # Generate the prefix-sum array.
        nums[i] += nums[i - 1]  # Add the cumulative sum of the previous index.
    ans = 0
    for left in range(len(nums)):
        for right in range(left, len(nums)):
            lSum = 0  # Initial sum is "0" before the left-most number.
            if(left > 0):
                lSum = nums[left - 1]  # Cumulative sum of numbers till "left - 1".
            rSum = nums[right]  # Cumulative sum of numbers to till "right".
            if(rSum - lSum == k):
                ans += 1
    return ans</code></pre></div> <p>
        We have optimized our solution to <strong>O(n<sup>2</sup>)</strong>, as
        the subarray sum is obtained in constant time now. The space complexity
        is either <strong>O(n)</strong> or <strong>O(1)</strong> depending on
        whether or not modifying the original array counts as using extra
        space.<br>
        This solution is much faster than the previous one but still too
        slow.<br><br>
        At first glance, this problem might appear to be solvable with the
        <a href="/article/11-LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="text-text-3 hover:underline focus:underline focus:outline-none">sliding window technique</a>, but it's not the case. Let's see why. Suppose, we have a large array
        like [1, -1, 1, -1......1, -1, 1] and the target sum is 0. The number of
        subarrays with an equal number of 0's and 1's are of an order of
        <strong>n<sup>2</sup></strong>. A sliding window will not be able to count all of these. This is
        because a sliding window expands towards the right and shrinks from the
        left <strong>n</strong> times each.<br>
        Let's consider the previous example again. [1, -1, 1, -1, 1, -1] can be
        modified to a prefix-sum array [1, 0, 1, 0, 1, 0]. If the target sum is
        0, the subarrays will be 9 in total. Let's traverse our prefix-sum array
        <em>sum</em> from left to right to see if we can find a pattern.<br><br>
        At <em>nums[0]</em> our <em>rSum</em> is 1. To obtain 0 as the final
        sum, we need to find an <em>lSum</em> equal to 1(i.e. 1 - 1 = 0). As
        this is the first index, we cannot find a non-zero <em>lSum</em> to the
        left.<br>
        At <em>nums[1]</em> our <em>rSum</em> is 0. We need to find an
        <em>lSum</em> equal to 0. This time, the <em>lSum</em> before the first
        index(initial sum) is equal to zero. So, we have obtained one subarray
        so far.<br>
        At <em>nums[2]</em>, our <em>rSum</em> is 1. We have already encountered
        a 1 before and can obtain another subarray, bringing our tally to 2.<br>
        At <em>nums[3]</em>, our <em>rSum</em> is 0. We have encountered 0
        twice(before the first index and at index-1) and can obtain two more
        zero-sum subarrays.<br>
        We repeat this process for the remaining elements to find a total of 9
        subarrays.<br><br>
        We notice that if the target sum is <em>k</em>, for every cumulative sum
        <em>rSum</em>, we need to find the total number of cumulative sums to
        the left that are equal to <em>rSum - k</em> (since
        <em>rSum - lSum = k</em>).<br>
        Now, let's look at the code.
      </p> <div class="sm:mx-10 my-4"><pre><code class="language-java">// Java
public int subarraySum(int[] nums, int k) {
    for (int i = 1; i &lt; nums.length; ++i) {
        nums[i] += nums[i - 1];
    }
    Map&lt;Integer, Integer> count = new HashMap&lt;>(); // Maintain a count of each sum obtained so far.
    count.put(0, 1); // Initial sum of "0" encountered once at the beginning.
    int ans = 0;
    for (int i = 0; i &lt; nums.length; ++i) {
        ans += count.getOrDefault(nums[i] - k, 0); // Add the count of "nums[i] - k" encountered till now.
        count.put(nums[i], count.getOrDefault(nums[i], 0) + 1); // Increment the count of the current sum "nums[i]".
    }
    return ans;
}</code></pre></div> <div class="sm:mx-10 my-4"><pre><code class="language-python"># Python3
def subarraySum(nums: List[int], k: int) -> int:
    from collections import defaultdict  # Dictionary that returns a default value for non-existing keys.
    for i in range(1, len(nums)):
        nums[i] += nums[i - 1]
    ans = 0
    count = defaultdict(int)  # Maintain a count of each sum obtained so far. This "defaultdict" returns "0" by default.
    count[0] = 1  # Initial sum of "0" encountered once at the beginning.
    for i in range(len(nums)):
        ans += count[nums[i] - k]  # Add the count of "nums[i] - k" encountered till now.
        count[nums[i]] += 1  # Increment the count of the current sum "nums[i]".
    return ans</code></pre></div> <p>
        This solution has the optimal <strong>O(n)</strong> time complexity. It
        also uses <strong>O(n)</strong> extra space for the
        <em>count</em> map/dictionary.<br>
        The problem turned out to be much simpler than it looked. We started
        from the brute-force technique and optimized it further and further by
        observing patterns.<br><br>
        Hooray! You've solved a medium-level problem. But don't stop here and
        try some more problems.
      </p></article></main> <footer class="container mx-auto mt-24 p-4 sm:px-8"><section class="flex justify-between"><a rel="noopener noreferrer" href="https://www.instagram.com/the_source_project" target="_blank" class="flex flex-col items-center group focus:outline-none"><p>Follow Us On</p> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="mt-2 h-10 w-10 group-hover:animate-bounce group-focus:animate-bounce"><path fill="currentColor" d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"></path></svg></a> <a href="/about-us" class="flex flex-col items-center group focus:outline-none"><p>About Us</p> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="mt-2 h-10 w-10 group-hover:animate-bounce group-focus:animate-bounce"><path fill="currentColor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"></path></svg></a> <button href="https://www.instagram.com/the_source_project" target="_blank" class="flex flex-col items-center group focus:outline-none"><p>Back To Top</p> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500" fill="none" stroke="currentColor" stroke-width="25" class="mt-2 h-10 w-10 group-hover:animate-bounce group-focus:animate-bounce focus:outline-none"><circle cx="250.22" cy="250.39" r="236.49"></circle> <path d="M183.31 283.89l65.81-69.12 68.01 71.24" stroke-miterlimit="10" stroke-linecap="round"></path></svg></button></section> <p class="mt-4 text-center text-sm opacity-75">
    2021, The Source Project
  </p></footer></div></div></div><script defer src="/_nuxt/static/1618949658/article/13-LeetCode-560-Subarray-Sum-Equals-K/state.js"></script><script src="/_nuxt/5a581fa.js" defer></script><script src="/_nuxt/7399833.js" defer></script><script src="/_nuxt/84f9ad6.js" defer></script><script src="/_nuxt/bababfc.js" defer></script><script src="/_nuxt/8e6facb.js" defer></script>
  </body>
</html>
